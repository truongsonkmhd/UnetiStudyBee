package com.truongsonkmhd.unetistudy.service.impl.quiz;

import com.truongsonkmhd.unetistudy.cache.CacheConstants;
import com.truongsonkmhd.unetistudy.cache.service.ScoreWriteBehindService;
import com.truongsonkmhd.unetistudy.common.AttemptStatus;
import com.truongsonkmhd.unetistudy.model.quiz.Quiz;
import com.truongsonkmhd.unetistudy.model.quiz.Answer;
import com.truongsonkmhd.unetistudy.model.quiz.Question;
import com.truongsonkmhd.unetistudy.model.quiz.UserAnswer;
import com.truongsonkmhd.unetistudy.model.quiz.UserQuizAttempt;
import com.truongsonkmhd.unetistudy.repository.quiz.*;
import com.truongsonkmhd.unetistudy.service.QuizService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Service xử lý Quiz attempts với tích hợp Caching
 * 
 * Cache Patterns áp dụng:
 * 1. Cache-Aside - Cache câu hỏi và đáp án
 * 2. Write-Behind - Ghi điểm thi async để giảm tải DB
 * 3. Time-based Expiration - TTL cho questions cache
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class QuizServiceImpl implements QuizService {

        private final QuizQuestionRepository quizRepository;
        private final QuestionRepository questionRepository;
        private final AnswerRepository answerRepository;
        private final UserQuizAttemptRepository attemptRepository;
        private final UserAnswerRepository userAnswerRepository;
        private final ScoreWriteBehindService scoreWriteBehindService;

        @Override
        @Transactional
        public UserQuizAttempt startQuizAttempt(UUID userId, UUID quizId) {
                Quiz quiz = getQuizCached(quizId);

                if (!quiz.getIsPublished()) {
                        throw new RuntimeException("Quiz is not published");
                }

                UserQuizAttempt attempt = UserQuizAttempt.builder()
                                .userId(userId)
                                .quiz(quiz)
                                .startedAt(Instant.now())
                                .status(AttemptStatus.IN_PROGRESS)
                                .build();

                return attemptRepository.save(attempt);
        }

        /**
         * Cache-Aside: Lấy quiz từ cache hoặc DB
         */
        @Cacheable(cacheNames = CacheConstants.QUIZ_BY_ID, key = "'entity:' + #quizId", unless = "#result == null")
        public Quiz getQuizCached(UUID quizId) {
                log.debug("Cache MISS - Loading quiz entity from DB: {}", quizId);
                return quizRepository.findById(quizId)
                                .orElseThrow(() -> new RuntimeException("Quiz not found"));
        }

        /**
         * Cache-Aside: Lấy questions của quiz từ cache
         */
        @Override
        @Transactional(readOnly = true)
        @Cacheable(cacheNames = CacheConstants.QUIZ_QUESTIONS, key = "#attemptId", unless = "#result == null")
        public Question getNextQuestion(UUID attemptId) {
                log.debug("Getting next question for attempt: {}", attemptId);

                UserQuizAttempt attempt = attemptRepository.findById(attemptId)
                                .orElseThrow(() -> new RuntimeException("Attempt not found"));

                Set<UUID> answeredQuestionIds = attempt.getUserAnswers().stream()
                                .map(ua -> ua.getQuestion().getId())
                                .collect(Collectors.toSet());

                List<Question> questions = getQuestionsCached(attempt.getQuiz().getId());

                return questions.stream()
                                .filter(q -> !answeredQuestionIds.contains(q.getId()))
                                .findFirst()
                                .orElse(null);
        }

        /**
         * Cache-Aside: Lấy danh sách questions từ cache
         */
        @Cacheable(cacheNames = CacheConstants.QUIZ_QUESTIONS, key = "'list:' + #quizId")
        public List<Question> getQuestionsCached(UUID quizId) {
                log.debug("Cache MISS - Loading questions from DB for quiz: {}", quizId);
                Quiz quiz = quizRepository.findById(quizId)
                                .orElseThrow(() -> new RuntimeException("Quiz not found"));
                return questionRepository.findByQuizOrderByQuestionOrderAsc(quiz);
        }

        @Override
        @Transactional
        public UserAnswer submitAnswer(UUID attemptId, UUID questionId,
                        Set<UUID> selectedAnswerIds,
                        Integer timeSpentSeconds) {
                UserQuizAttempt attempt = attemptRepository.findById(attemptId)
                                .orElseThrow(() -> new RuntimeException("Attempt not found"));

                Question question = questionRepository.findById(questionId)
                                .orElseThrow(() -> new RuntimeException("Question not found"));

                boolean isTimeout = timeSpentSeconds > question.getTimeLimitSeconds();

                Set<Answer> selectedAnswers = new HashSet<>();
                if (selectedAnswerIds != null && !selectedAnswerIds.isEmpty()) {
                        selectedAnswers = new HashSet<>(answerRepository.findAllById(selectedAnswerIds));
                }

                Set<UUID> correctAnswerIds = question.getAnswers().stream()
                                .filter(Answer::getIsCorrect)
                                .map(Answer::getId)
                                .collect(Collectors.toSet());

                boolean isCorrect = !isTimeout && correctAnswerIds.equals(selectedAnswerIds);
                double pointsEarned = isCorrect ? question.getPoints() : 0.0;

                UserAnswer userAnswer = UserAnswer.builder()
                                .attempt(attempt)
                                .question(question)
                                .selectedAnswers(selectedAnswers)
                                .isCorrect(isCorrect)
                                .pointsEarned(pointsEarned)
                                .timeSpentSeconds(timeSpentSeconds)
                                .isTimeout(isTimeout)
                                .build();

                attempt.addUserAnswer(userAnswer);
                return userAnswerRepository.save(userAnswer);
        }

        /**
         * Write-Behind: Hoàn thành quiz và ghi điểm
         * Điểm được ghi vào cache ngay lập tức
         * Background thread sẽ flush vào DB định kỳ
         */
        @Override
        @Transactional
        public UserQuizAttempt completeQuizAttempt(UUID attemptId) {
                log.info("Completing quiz attempt: {}", attemptId);

                UserQuizAttempt attempt = attemptRepository.findById(attemptId)
                                .orElseThrow(() -> new RuntimeException("Attempt not found"));

                // Tính điểm
                double totalScore = attempt.getUserAnswers().stream()
                                .mapToDouble(UserAnswer::getPointsEarned)
                                .sum();

                List<Question> questions = getQuestionsCached(attempt.getQuiz().getId());
                double totalPossiblePoints = questions.stream()
                                .mapToDouble(Question::getPoints)
                                .sum();

                double percentage = totalPossiblePoints > 0
                                ? (totalScore / totalPossiblePoints) * 100
                                : 0.0;

                boolean isPassed = attempt.getQuiz().getPassScore() != null
                                && percentage >= attempt.getQuiz().getPassScore();

                attempt.setScore(totalScore);
                attempt.setTotalPoints(totalPossiblePoints);
                attempt.setPercentage(percentage);
                attempt.setIsPassed(isPassed);
                attempt.setCompletedAt(Instant.now());
                attempt.setStatus(AttemptStatus.COMPLETED);

                // Lưu vào DB ngay (vì cần ID)
                UserQuizAttempt savedAttempt = attemptRepository.save(attempt);

                // Write-Behind: Ghi vào cache để tracking và analytics
                // Có thể dùng cho việc aggregate scores sau
                scoreWriteBehindService.recordScore(savedAttempt);

                log.info("Quiz attempt completed: attemptId={}, score={}, passed={}",
                                attemptId, totalScore, isPassed);

                return savedAttempt;
        }

        @Override
        @Transactional(readOnly = true)
        public List<UserQuizAttempt> getUserAttempts(UUID userId, UUID quizId) {
                return attemptRepository.findByUserIdAndQuizOrderByCreatedAtDesc(userId, quizId);
        }
}